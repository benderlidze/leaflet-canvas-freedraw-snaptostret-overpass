<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin="" />
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>


<button id="drawMode">Draw mode</button>
<button id="panMode">Map mode</button>
<div id="map"></div>
<canvas id="canvas" width="1000" height="1000"></canvas>

<style>
    html,
    body {
        height: 100%;
        margin: 0;
    }

    .leaflet-container {
        height: 1000px;
        width: 1000px;
        max-width: 100%;
        max-height: 100%;
    }

    canvas {
        cursor: crosshair;
        border: 1px solid #000000;
    }
</style>

<script>

    const drawMode = document.querySelector("#drawMode")
    const panMode = document.querySelector("#panMode")

    const LAT_LNG = [51.505, -0.09];
    const TILE_URL = 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}@2x.png';

    const map = new L.Map(document.querySelector('#map'), { doubleClickZoom: false }).setView(LAT_LNG, 16);
    L.tileLayer(TILE_URL).addTo(map);


    var geojsonFeature = {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "properties": {},
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        [
                            -0.09567975997924805,
                            51.504922725092044
                        ],
                        [
                            -0.09299755096435547,
                            51.50468231156
                        ],
                        [
                            -0.09003639221191406,
                            51.50484258738895
                        ],
                        [
                            -0.09168863296508789,
                            51.50327987400937
                        ],
                        [
                            -0.09312629699707031,
                            51.50134310357631
                        ],
                        [
                            -0.09443521499633788,
                            51.50162360646046
                        ],
                        [
                            -0.09563684463500977,
                            51.50227810647596
                        ],
                        [
                            -0.0960874557495117,
                            51.502919240234235
                        ]
                    ]
                }
            }
        ]
    };

    L.geoJSON(geojsonFeature).addTo(map);



    map.whenReady(draw)


    drawMode.addEventListener("click", () => {
        map.dragging.disable();
    })
    panMode.addEventListener("click", () => {
        map.dragging.enable();
    })

    function draw() {

        //Canvas
        var canvas = document.getElementById('canvas');
        canvas.style.position = 'relative'
        canvas.style.zIndex = '1001'
        canvas.style.pointerEvents = 'none'
        var ctx = canvas.getContext('2d');
        //Variables
        var canvasx = canvas.offsetLeft;
        var canvasy = canvas.offsetTop;
        var last_mousex = last_mousey = 0;
        var mousex = mousey = 0;
        var mousedown = false;
        var tooltype = 'draw';

        // //Mousedown
        // canvas.addEventListener('mousedown', function (e) {
        //     last_mousex = mousex = parseInt(e.clientX - canvasx);
        //     last_mousey = mousey = parseInt(e.clientY - canvasy);
        //     mousedown = true;
        // });

        // //Mouseup
        // canvas.addEventListener('mouseup', function (e) {
        //     mousedown = false;
        // });

        // //Mousemove
        // canvas.addEventListener('mousemove', function (e) {
        //     mousex = parseInt(e.clientX - canvasx);
        //     mousey = parseInt(e.clientY - canvasy);
        //     if (mousedown) {
        //         ctx.beginPath();
        //         if (tooltype == 'draw') {
        //             ctx.globalCompositeOperation = 'source-over';
        //             ctx.strokeStyle = 'black';
        //             ctx.lineWidth = 3;
        //         }
        //         ctx.moveTo(last_mousex, last_mousey);
        //         ctx.lineTo(mousex, mousey);
        //         ctx.lineJoin = ctx.lineCap = 'round';
        //         ctx.stroke();
        //     }
        //     last_mousex = mousex;
        //     last_mousey = mousey;
        // });


        map.getContainer().append(canvas)

        const mouseDown = event => {

            const point = map.mouseEventToContainerPoint(event.originalEvent);
            map.containerPointToLatLng(point)
            last_mousex = point.x
            last_mousey = point.y


            const mouseMove = event => {

                // Resolve the pixel point to the latitudinal and longitudinal equivalent.
                const point = map.mouseEventToContainerPoint(event.originalEvent);
                // Push each lat/lng value into the points set.
                map.containerPointToLatLng(point)

                mousex = point.x;
                mousey = point.y;

                ctx.beginPath();
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.moveTo(last_mousex, last_mousey);
                ctx.lineTo(mousex, mousey);
                ctx.lineJoin = ctx.lineCap = 'round';
                ctx.stroke();
                //lineIterator(new Point(point.x, point.y));
                last_mousex = mousex;
                last_mousey = mousey;
            };

            // Create the path when the user moves their cursor.
            map.on('mousemove touchmove', mouseMove);

            const mouseUp = (_, create = true) => {
                // Stop listening to the events.
                map.off('mouseup', mouseUp);
                map.off('mousemove', mouseMove);
                'body' in document && document.body.removeEventListener('mouseleave', mouseUp);
                // svg.selectAll('*').remove();
            };

            // Clear up the events when the user releases the mouse.
            map.on('mouseup touchend', mouseUp);
            'body' in document && document.body.addEventListener('mouseleave', mouseUp);

        };

        map.on('mousedown touchstart', mouseDown);
    }



    function calcClosestPtOnSegment(x0, y0, x1, y1, cx, cy, cr) {

        // calc delta distance: source point to line start
        var dx = cx - x0;
        var dy = cy - y0;

        // calc delta distance: line start to end
        var dxx = x1 - x0;
        var dyy = y1 - y0;

        // Calc position on line normalized between 0.00 & 1.00
        // == dot product divided by delta line distances squared
        var t = (dx * dxx + dy * dyy) / (dxx * dxx + dyy * dyy);

        // calc nearest pt on line
        var x = x0 + dxx * t;
        var y = y0 + dyy * t;

        // clamp results to being on the segment
        if (t < 0) { x = x0; y = y0; }
        if (t > 1) { x = x1; y = y1; }

        return ({
            x: x, y: y,
            isColliding: ((cx - x) * (cx - x) + (cy - y) * (cy - y)) < cr * cr,
            isOnSegment: (t >= 0 && t <= 1),
        });
    }
</script>